ğŸ“Œ 1ï¸âƒ£ Indexing Pitfalls & Common Mistakes

Indexes improve performance, but misusing them can slow down queries and waste resources. Letâ€™s go over common mistakes and how to avoid them.

âŒ Mistake 1: Too Many Indexes

ğŸ”¹ Issue:
Adding too many indexes increases storage usage and slows down INSERT, UPDATE, and DELETE operations.

ğŸ”¹ Example:

CREATE INDEX idx_name ON users(name);
CREATE INDEX idx_email ON users(email);
CREATE INDEX idx_name_email ON users(name, email);

âš ï¸ Problem:

    The idx_name_email composite index already covers name and email.
    The individual idx_name and idx_email are redundant.
    More indexes = slower writes.

ğŸ”¹ Fix:
Remove unnecessary indexes:

DROP INDEX idx_name ON users;
DROP INDEX idx_email ON users;

âœ… Keep only idx_name_email to optimize queries that use both columns.

âŒ Mistake 2: Using an Index on Low-Cardinality Columns

ğŸ”¹ Issue:
Indexing columns with very few unique values (e.g., gender with only Male and Female) is useless.

ğŸ”¹ Bad Example:

CREATE INDEX idx_gender ON users(gender);

âš ï¸ Problem:

    Since there are only two values, MySQL still scans almost all rows.
    Index won't significantly improve performance.

ğŸ”¹ Fix:
Only index high-cardinality columns (many unique values).
Example: email or phone_number is a good choice.

âŒ Mistake 3: Wrong Order in Composite Indexes

ğŸ”¹ Issue:
Index column order matters in a composite index.

ğŸ”¹ Bad Example:

CREATE INDEX idx_name_age ON users(name, age);

âš ï¸ Problem:

    This index is useless for:

    SELECT * FROM users WHERE age = 30;

    Because MySQL only optimizes leftmost columns in an index.

ğŸ”¹ Fix:
If queries mostly filter by age first, create:

CREATE INDEX idx_age_name ON users(age, name);

âœ… Index order should match the most used query pattern.

âŒ Mistake 4: Using LIKE '%something%' (Leading Wildcards)

ğŸ”¹ Issue:
LIKE '%something%' prevents index usage because MySQL has to scan the whole column.

ğŸ”¹ Bad Example:

SELECT * FROM users WHERE name LIKE '%John%';

âš ï¸ Problem:

    MySQL cannot use the index when a wildcard (%) is at the beginning.
    Query becomes very slow (O(n)).

ğŸ”¹ Fix:
Use LIKE 'John%' instead:

SELECT * FROM users WHERE name LIKE 'John%';

âœ… Now MySQL can use a B-Tree index (O(log n)).

âŒ Mistake 5: Not Using EXPLAIN to Check Index Usage

ğŸ”¹ Issue:
Without EXPLAIN, you don't know if MySQL is actually using your index.

ğŸ”¹ Fix:
Use EXPLAIN before running queries:

EXPLAIN SELECT * FROM users WHERE email = 'john@example.com';

âœ… If EXPLAIN shows type=ALL, MySQL is not using an index, meaning you need to optimize indexing.

ğŸ“Œ 2ï¸âƒ£ Covering Indexes & Index-Only Queries

Covering indexes make queries extremely fast by storing all necessary columns in the index, eliminating the need to access the actual table.
ğŸ”¹ What is a Covering Index?

A covering index is an index that contains all columns required by a query, so MySQL can fetch data directly from the index instead of accessing the table.
ğŸ”¹ Example Without a Covering Index (Slow)

SELECT name, email FROM users WHERE age = 30;

âš ï¸ Problem:

    Even if we have an index on age, MySQL still has to read the full table to get name and email.

ğŸ”¹ Solution: Covering Index (Fast)

CREATE INDEX idx_age_name_email ON users(age, name, email);

âœ… Now MySQL can get all columns (name, email, age) from the index itself!
Run EXPLAIN:

EXPLAIN SELECT name, email FROM users WHERE age = 30;

If you see Extra: Using index, it means MySQL is using a covering index (super fast!).

ğŸ“Œ 3ï¸âƒ£ Simulating High Traffic with Concurrent Queries

Now, letâ€™s simulate high traffic and see how indexing affects performance.
ğŸ”¹ Step 1: Enable Query Profiling

SET profiling = 1;

ğŸ”¹ Step 2: Simulate 100 Concurrent Reads

Use sysbench or run multiple queries in parallel.

SELECT * FROM users WHERE email = 'user500000@example.com';

â³ Without an index: Query takes several seconds under load.
ğŸ”¹ Step 3: Add an Index & Retry

CREATE INDEX idx_email ON users(email);

ğŸš€ With an index: Query executes in milliseconds even with high traffic.
ğŸ”¹ Step 4: Measure Query Performance

After running queries, check execution times:

SHOW PROFILES;

âœ… Compare query execution time before & after indexing.

ğŸš€ Final Summary
Mistake / Optimization	Impact	Solution
Too many indexes	Slow INSERT/UPDATE/DELETE	Only create necessary indexes
Low-cardinality indexes	No performance boost	Index only high-cardinality columns
Wrong composite index order	Index not used	Match order to query patterns
Leading wildcard in LIKE	Index ignored	Use LIKE 'text%' instead
Not using EXPLAIN	Index might not be used	Always check with EXPLAIN
Covering Indexes	ğŸš€ Super fast queries	Store all needed columns in index
Simulating high traffic	See real-world impact	Measure with profiling