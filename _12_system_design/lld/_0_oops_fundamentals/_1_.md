# What is OOP (Object-Oriented Programming)?

Object-Oriented Programming (OOP) is a programming paradigm based on the concept of â€œobjectsâ€, which contain data (fields/properties/attributes) and methods (functions/behavior) that operate on that data.

In OOP, we model real-world entities as classes and their individual instances as objects.

# Key Concepts of OOP:

There are four core principles of OOP:

    Encapsulation â€“ Hiding internal state and requiring all interaction to be performed through an objectâ€™s methods.
    Abstraction â€“ Showing only essential features and hiding complexity.
    Inheritance â€“ Acquiring properties and behaviors from another class.
    Polymorphism â€“ One interface, many implementations (method overloading and overriding).

# OOP vs Other Paradigms:

    OOP emphasizes objects and behaviors.
    Procedural Programming (like C) focuses on procedures/functions and data separately.
    Functional Programming emphasizes pure functions and immutability.

# Why OOP?

    Models real-world entities naturally
    Promotes reusability through inheritance
    Easier maintenance and debugging
    Improved modularity through encapsulation
    Supports scalability and abstraction

# Advantages of OOP

Object-Oriented Programming offers several benefits that make it ideal for building large, maintainable, and reusable systems. Here's a breakdown of the key advantages:

1. Modularity (Separation of Concerns)

    Code is organized into classes and objects, making it modular.
    Each class is responsible for its own data and behavior.
    Encourages writing clean and maintainable code.

ğŸ§  Example: A User class manages user info. An Order class manages orders. No overlap.

2. Code Reusability

    Inheritance allows a new class to inherit properties/methods from an existing one.
    Promotes DRY (Don't Repeat Yourself) principle.

ğŸ§  Example: A Vehicle class can be extended by Car, Bike, Truck, etc.

3. Scalability and Maintainability

    Easier to update and scale large applications due to encapsulation and modular design.
    You can change a class's internals without affecting other parts of the code.

ğŸ§  If the BankAccount class changes internally, other classes using it donâ€™t need changes if public interfaces are intact.

4. Data Hiding (Encapsulation)

    Private variables restrict direct access.
    Public methods (getters/setters) control access to data.
    Ensures controlled access to sensitive data.

ğŸ§  You canâ€™t modify someoneâ€™s balance directly â€” you use deposit() or withdraw().

5. Flexibility through Polymorphism

    Same interface can be implemented in different ways.
    Makes your code flexible and easier to extend.

ğŸ§  A Shape can be a Circle, Square, or Triangle â€“ all share draw() method.

6. Abstraction (Simplifies Complexity)

    Users only see relevant information.
    Internal implementation is hidden.

ğŸ§  You can use a Database.connect() method without knowing how the connection is implemented.

7. Easier Testing and Debugging

    Objects are self-contained and modular.
    You can test units (classes) individually.

ğŸ§  You can test the LoginService class independently from the NotificationService.

8. Real-World Mapping

    OOP models real-world systems naturally.
    Makes it intuitive for developers to design systems.

ğŸ§  Classes like Customer, Invoice, and Payment mirror real-world entities.
