üöÄ Simulating High Traffic with Concurrent Queries in MySQL

1Ô∏è‚É£ Set up a large dataset (1M+ rows).
2Ô∏è‚É£ Enable query profiling to measure performance.
3Ô∏è‚É£ Run queries without indexes under high load.
4Ô∏è‚É£ Add indexes and rerun the queries to compare performance.
5Ô∏è‚É£ Use sysbench to simulate multiple concurrent users.

1Ô∏è‚É£ Setup: Create a Large Dataset (1M+ Rows)

üîπ Create Table
   CREATE TABLE users (
    id INT PRIMARY KEY AUTO_INCREMENT,
    name VARCHAR(100),
    email VARCHAR(255),
    age INT,
    created_at DATETIME DEFAULT CURRENT_TIMESTAMP
   );

üîπ Insert 1 Million Users
DELIMITER $$

CREATE PROCEDURE InsertUsers()
BEGIN
    DECLARE i INT DEFAULT 0;
    WHILE i < 1000000 DO
        INSERT INTO users (name, email, age)
        VALUES (
            CONCAT('User', i),
            CONCAT('user', i, '@example.com'),
            FLOOR(18 + (RAND() * 60))
        );
        SET i = i + 1;
    END WHILE;
END $$

DELIMITER ;

CALL InsertUsers();


2Ô∏è‚É£ Enable Query Profiling
Query profiling lets us measure query execution time.

SET profiling = 1;

Run a simple test query:

SELECT COUNT(*) FROM users;
SHOW PROFILES;

‚úÖ This enables profiling for performance analysis.


3Ô∏è‚É£ Run Queries Without Indexes

üîπ Query 1: Search by Email
SELECT * FROM users WHERE email = 'user500000@example.com';

Check Query Execution Plan
EXPLAIN SELECT * FROM users WHERE email = 'user500000@example.com';

‚ö†Ô∏è Expected Output:

    If type = ALL, it means MySQL is doing a full table scan (O(n)).
    This will be very slow (several seconds on large datasets).

üîπ Query 2: Filter by Age Range

SELECT * FROM users WHERE age BETWEEN 30 AND 40;

Check Query Execution Plan

EXPLAIN SELECT * FROM users WHERE age BETWEEN 30 AND 40;

‚ö†Ô∏è Expected Output:

    Again, MySQL will do a full table scan.
    Performance will be poor.

üîπ Query 3: Sorting Users by Name

SELECT * FROM users ORDER BY name ASC LIMIT 100;

Check Query Execution Plan

EXPLAIN SELECT * FROM users ORDER BY name ASC LIMIT 100;

‚ö†Ô∏è Expected Output:

    MySQL sorts all 1 million rows in memory (O(n log n)).
    Sorting without an index is very slow.

4Ô∏è‚É£ Add Indexes and Rerun Queries

Now, let‚Äôs add indexes and see the performance improvement.
üîπ Index for Fast Email Lookup

CREATE INDEX idx_email ON users(email);

Rerun Query 1:

EXPLAIN SELECT * FROM users WHERE email = 'user500000@example.com';

‚úÖ Expected Improvement:

    The query should now be instant (O(log n)).

üîπ Index for Fast Age Filtering

CREATE INDEX idx_age ON users(age);

Rerun Query 2:

EXPLAIN SELECT * FROM users WHERE age BETWEEN 30 AND 40;

‚úÖ Expected Improvement:

    Instead of scanning all rows, MySQL jumps to age = 30 and scans forward.

üîπ Index for Sorting

CREATE INDEX idx_name ON users(name);

Rerun Query 3:

EXPLAIN SELECT * FROM users ORDER BY name ASC LIMIT 100;

‚úÖ Expected Improvement:

    Instead of sorting 1 million rows in memory, MySQL retrieves already sorted data.



5Ô∏è‚É£ Simulating High Traffic with sysbench

Now, let‚Äôs simulate multiple concurrent users running queries at the same time.
üîπ Install Sysbench (if not installed)

Run this on Mac (Homebrew):

brew install sysbench

Or on Linux (Ubuntu/Debian):

sudo apt-get install sysbench


üîπ Step 1: Run 50 Concurrent Reads Without Index

Run a read-only workload before adding indexes:

sysbench oltp_read_only --mysql-host=localhost \
--mysql-user=root --mysql-password=yourpassword \
--mysql-db=test --table-size=1000000 \
--threads=50 --time=30 --report-interval=10 \
run

üî¥ Expected Result:

    High latency (~several seconds per query).
    MySQL CPU usage spikes due to full table scans.

üîπ Step 2: Add Indexes & Run Again

Now add the indexes:

CREATE INDEX idx_email ON users(email);
CREATE INDEX idx_age ON users(age);
CREATE INDEX idx_name ON users(name);

‚úÖ Now rerun the test:

sysbench oltp_read_only --mysql-host=localhost \
--mysql-user=root --mysql-password=yourpassword \
--mysql-db=test --table-size=1000000 \
--threads=50 --time=30 --report-interval=10 \
run

üü¢ Expected Result:

    Queries now complete in milliseconds.
    CPU usage drops, MySQL efficiently retrieves data using indexes.

üöÄ Performance Gains Summary
Query Type	Without Index (Slow)	With Index (Fast)
Search by Email	Full table scan (O(n))	Instant lookup (O(log n)) ‚úÖ
Filter by Age	Full table scan (O(n))	Index scan (O(log n)) ‚úÖ
Sorting by Name	Sorting in memory (O(n log n))	Index scan (O(log n)) ‚úÖ
Concurrent Queries (50 users)	High CPU, slow queries	Fast, low CPU usage ‚úÖ    